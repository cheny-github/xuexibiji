# JUC

### 内存可见性

​	如果一个线程对共享变量的修改，能够被其它线程看到，那么就能说明共享变量在线程之间是可见的。如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。Java内存模型（Java Memory Model,JMM）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。所有的变量都储存在主内存中。每个线程都有自己独立的工作内存，里面保存了该线程使用到的变量的副本（主内存中该变量的一份拷贝），如下图所示。



![](.\img\TIM截图20190411191040.jpg)

为什么会出现共享变量可见性的问题，这是因为线程对共享变量的所有操作都必须在自己的工作内存中进行，不能从主内存中读写；而且不同线程之间无法直接访问其它线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。线程1对共享变量的修改要想被线程2及时看到，必须要经过如下两个步骤：
1. 把工作内存1中更新过的共享变量刷新到主内存中；
2. 把内存中最新的共享变量的值更新到工作内存2中
Java语言层面支持的可见性实现方式有两种：
1.	synchronized
2.	volatile

synchronized不仅能通过互斥锁来实现同步，而且还能够实现可见性。Java内存模型关于Synchronized有两条规定：
* 线程释放锁之前，JMM会将工作内存中的共享变量刷新到主内存中；
* 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值
线程执行互斥代码的过程：
1. 获取监视器锁

2. 清空工作内存

3. 从主内存中拷贝变量的最新副本到工作内存

4. 执行代码

5. 将更改后的共享变量的值刷新到主内存

6. 释放监视器锁
  如果某个任务处于一个对标记为synchronized的方法的调用中，那么在这个线程从该方法返回之前，其它所有要调用类中任何标记为synchronized方法的线程都会被阻塞。

  

  

  

  volatile通过加入内存屏障和禁止指令重排序优化来实现的：
* 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令，这样就会把读写时的数据缓存加载到主内存中；
* 对volatile变量执行读操作时，会在读操作前加入一条load屏障指令，这样就会从主内存中加载变量；
  所以说，volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，而当该变量发生变化时，就会强迫线程将最新的值刷新到主内存，这样任何时刻，不同的线程总能看到该变量的最新值。线程写volatile变量的过程：
1.	改变线程工作内存中volatile变量副本的值；
2.	将改变后的副本的值从工作内存刷新到主内存中
   线程读volatile变量的过程：
3.	从主内存中读取volatile变量的最新值到线程的工作内存中；
4.	从工作内存中读取volatile变量的副本

二者比较：

​	volatile是一个轻量级的同步策略不具有原子性和互斥性，相对于synchronized的效率更高。



### 原子变量

jdk1.5以后提供的java.util.concurrent.atomic包提供了常用的原子变量，这些变量有如下特性：

1. volatile 保证内存可见性

2. CAS(compare and swap) 算法保证了数据的原子性

   CAS算法是硬件对于并发操作共享数据的支持

   CAS包含了三个操作数：

   内存值V

   预估值A

   更新值B

   当且仅当V==A时，才进行V=B的赋值，否则将不做任何操作

   